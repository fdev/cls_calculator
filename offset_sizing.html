<!DOCTYPE html>
<head>


	<style>
	body {
		color:  lightgray;
		background-color: #202020;
	}
	.family-name {
		font-family:  monospace;
		font-size: 4em;
		color: gray;
		margin-top: 1em;
	}
	/* Apparently this is how we put things on top of each other */
	.sample-container {
		display:  inline-grid;
		column-gap:  1em;
	}
	.lhs {
		grid-column: 1;
		grid-row:  1;
	}
	.rhs {
		grid-column: 2;
		grid-row:  1;
	}
	.snippet {
		grid-column: 3;
		grid-row:  1;
		white-space: pre;
		font-family:  monospace;
		font-size: 1.25em;
	}

	/* Nice to be able to distinguish samples */
	.sample-container :nth-child(1n) > div  {
		color:  darkseagreen;
		opacity: 0.6;
	}
	.sample-container :nth-child(2n) > div  {
		color:  deepskyblue;
		opacity: 0.6;
	}
	.border-lb {
		border-bottom: 1px dashed;
		border-right: 1px dashed;
	}
	.font-sample {
		white-space: break-spaces;
		display:  inline-block;
	}
	.webfont {
		color: darkseagreen;
	}
	.local {
		color: deepskyblue;
	}
	</style>
</head>
<body>
<script>
const t0 = performance.now();

(async function() {
  const os = currentOS();
  const measure_size = "3em";
  const measure_text = [1,1,1].map(v => "AEIHQRSTaej\u00feforst1052").join("\n");
  let web_family = requireQuery('web');
  let local_family = requireQuery('local');

  let [fallbacks, families] = await familiesAndFallbacks(web_family, local_family);

  const fallback_sheets = [];

  // for debug convenience
  window.fallbacks = fallbacks;
  window.families = families;
  window.os = os;

  // TODO it would be ideal to try to position the ink in the same
  // place via ascent/descent/line-gap override. For now we effectively
  // copy Malte's algorithm to try to hit the same box.
  // Align size on X then use ascent to align Y
  const resizers = [
  	{
  		"cssProperty": "sizeAdjust",
  		"cssDescriptor": "size-adjust",
  		"measureProperty": "offsetWidth",
  		"min": 50,
  		"initial": 100,
  		"max": 200,
  		"cssFormat": (v) => `${v.toFixed(2)}%`
  	},
  	{
  		// TODO: line-height?
  		"cssProperty": "ascentOverride",
  		"cssDescriptor": "ascent-override",
  		"measureProperty": "offsetHeight",
  		"min": 50,
  		"initial": 100,
  		"max": 200,
  		"cssFormat": (v) => `${v.toFixed(2)}%`
  	}
  ];

  function requireQuery(name) {
  	var value = new URLSearchParams(window.location.search).get(name);
  	if (value == null) {
  		throw `${name} must be specified`;
  	}
  	value = value.trim();
  	if (value.length == 0) {
  		throw `${name} invalid`;
  	}
  	return value;
  }

  function currentOS() {
		if (window.navigator.platform.startsWith("Mac")) return "mac";
		if (window.navigator.userAgent.startsWith("Mozilla/5.0 (X11; Linux ")) return "linux";
		if (window.navigator.userAgent.startsWith("Mozilla/5.0 (Linux; Android ")) return "android";
		throw "Not sure what target OS is";
  };

  async function familiesAndFallbacks(web_family, local_family) {
  	let families = (await (await fetch('./fonts.json')).json())
	  	.familyMetadataList.filter(e => e.family == web_family);

	  if (families.length == 0) {
	  	throw `${web_family} has no family definition`
	  }

  	let fallbacks = {};
  	for (family of families) {
  		family_fallbacks = [];

  		for (font_pos in family.fonts) {
  			let style = font_pos.endsWith("i") ? "italic" : "normal";
  			let weight = parseInt(font_pos.substring(0, 3));
  			family_fallbacks.push({
  				"wght": weight,
  				"style": style,
  				"local": local_family
  			});
  		}

  		if (family_fallbacks.length > 0) {
  			fallbacks[family.family] = family_fallbacks;
  		}
  	}

	  return [fallbacks, families.filter(e => e.family in fallbacks)];
  };

  function generateFallbackFaces(web_family, fallback, positions) {
  	let css = [
	  		"@font-face {",
	  		`	font-family: "${unadjusted_fallback_name(web_family)}";`,
	  		`	font-weight: ${fallback.wght};`,
	  		`	font-style: ${fallback.style};`,
	  		`	src: local("${fallback.local}");`,
	  		"}",
	  		"@font-face {",
	  		`	font-family: "${fallback_name(web_family)}";`,
	  		`	font-weight: ${fallback.wght};`,
	  		`	font-style: ${fallback.style};`,
	  		`	src: local("${fallback.local}");`,
		];
		for (i in resizers) {
			desc = resizers[i].cssDescriptor;
			value = resizers[i].cssFormat(positions[i]);
			css.push(`	${desc}: ${value};`);
		}
		css.push("}");
		css = css.join("\n");
		if (css.indexOf('undefined') != -1) {
			throw css;
		}
		console.log(css);
		return css;
  };

  function resize(web_family, fallback, webfont_el, fallback_el) {

  	console.log("Resize", web_family, make_css_api_name(web_family, fallback));

  	positions = resizers.map(r => r.initial);
  	fallback.sheet.replaceSync(generateFallbackFaces(web_family, fallback, positions));

  	for (let i = 0; i < resizers.length; i++) {
  		resizer = resizers[i];
  		console.log(`Match ${web_family} & ${make_css_api_name(web_family, fallback)} using ${resizer.cssDescriptor}`);
  		let target = webfont_el[resizer.measureProperty];
  		var step = (resizer.max - positions[i]) / 2;
  		var actual = fallback_el[resizer.measureProperty];

  		while (Math.abs(target - actual) > 1 && Math.abs(step) > 0.1) {
  			actual = fallback_el[resizer.measureProperty];
  			console.log("pos", positions, "step", step, "target", target, "actual", actual);
  			if (actual == target) break;
  			if (Math.sign(target - actual) != Math.sign(step)) {
  				step = -step / 2;
  			}
  			positions[i] += step;
  			fallback.sheet.replaceSync(generateFallbackFaces(web_family, fallback, positions));

  			if (positions[i] < resizer.min || positions[i] > resizer.max) {
  				console.log("out of bounds");
  				break;
  			}
  		}
  	}
  };

  function fallback_name(family_name) {
  	return family_name.replace(/ /g, "_").replace(/"/g, "").toLowerCase() + "-fallback";
  }

  function unadjusted_fallback_name(family_name) {
  	return family_name.replace(/ /g, "_").replace(/"/g, "").toLowerCase() + "-unadjusted";
  }

	function make_css_api_name(family, fallback) {
		let tags = 'ital,wght';
		let ital = fallback.style == 'italic' ? 1 : 0;
		return `${family.replace(/ /g, "+")}:${tags}@${ital},${fallback.wght}`;
	}

  function make_css_url(family, fallback) {
  	return `https://fonts.googleapis.com/css2?family=${make_css_api_name(family, fallback)}`;
  }

  await Promise.all(families
  	.flatMap(family => fallbacks[family.family].map(fallback => [family.family, fallback]))
  	.map(async inputs => {
  		[family, fallback] = inputs

	  	const css_url = make_css_url(family, fallback);
	  	const css_start = performance.now();
			css_content = await (await fetch(css_url)).text();
			const css_end = performance.now();
			console.log(css_url, css_end - css_start, "ms");

			style = document.createElement("style");
			style.innerHTML = css_content;
			document.head.appendChild(style);
  	}));
  console.log("CSS ready.", performance.now() - t0, "ms");

  load_promises = []
  for (var fontFace of document.fonts.values()) {
  	if (fontFace.family in fallbacks) {
  		load_promises.push(fontFace.load());
  	}
  }
  await Promise.all(load_promises);
  console.log("Fonts ready.", performance.now() - t0, "ms");

  let all_sheets = []
  for (let family of families) {
  	for (var fallback of fallbacks[family.family]) {
  		let web_family = family.family;
  		// A sheet to resize
  		let sheet = new CSSStyleSheet();
  		sheet.replaceSync(generateFallbackFaces(web_family, fallback, resizers.map(r => r.initial)));
  		fallback.sheet = sheet;
  		all_sheets.push(sheet);
  	}
  }

  document.adoptedStyleSheets = all_sheets;

  for (let family of families) {
  	for (let fallback of fallbacks[family.family]) {
	  	let container_el = document.createElement("div");
	  	let title_el = document.createElement("div");
	  	let webfont_el = document.createElement("div");
	  	let fallback_el = document.createElement("div");

	  	container_el.classList.add("sample-container");

			webfont_el.style.fontFamily = family.family;
			fallback_el.style.fontFamily = fallback_name(family.family);

			title_el.innerHTML = `<span class="webfont">${make_css_api_name(family.family, fallback)}</span> / <span class="local">${fallback.local}</span>`;
			title_el.classList.add("family-name");

	  	document.body.appendChild(title_el);
	  	document.body.appendChild(container_el);

	  	// If we drop our carefully sized elements into the grid it somehow screws sizing up
	  	[webfont_el, fallback_el].forEach(el => {
	  		note = document.createElement("div");
		  	note.innerText = "Adjusted";

				el.innerHTML = measure_text;
				el.style.fontSize = measure_size;
				el.style.fontWeight = fallback.wght;
				el.classList.add("font-sample");
				el.classList.add("border-lb");

				div = document.createElement("div");
				div.classList.add("rhs");
				div.appendChild(note);
				div.appendChild(el);

				container_el.appendChild(div);
	  	});

	  	resize(family.family, fallback, webfont_el, fallback_el);

	  	// It's interesting to see the non-resized version too
	  	[webfont_el, fallback_el].forEach(el => {
	  		let note = document.createElement("div");
		  	note.innerText = "Original";

	  		let original = document.createElement("div");
	  		if (Object.is(el, fallback_el)) {
	  			original.style.fontFamily = unadjusted_fallback_name(family.family, fallback);
	  		} else {
	  			original.style.fontFamily = el.style.fontFamily;
	  		}
	  		original.style.fontWeight = el.style.fontWeight;
	  		original.style.fontSize = measure_size;
	  		original.innerHTML = measure_text;
	  		original.classList.add("font-sample");

				div = document.createElement("div");
				div.classList.add("lhs");
				div.appendChild(note);
				div.appendChild(original);
				container_el.appendChild(div);
	  	});

	  	// Populate code snippet
	  	let fallback_style = fallback.sheet.rules[1].style;
	  	if (fallback_style.fontFamily != fallback_el.style.fontFamily) {
	  		throw "Wrong sheet for code snippet";
	  	}
	  	snippet = [
	  		"fallbacks {",
	  		"  axis_target {",
	  		"    tag: \"wght\"",
	  		`    min_value: ${fallback.wght}`,
	  		`    max_value: ${fallback.wght}`,
	  		"  }",
	  		"  target {",
	  		`    target_type: TARGET_OS_${os.toUpperCase()}`,
	  		"  }",
	  		`  size_adjust_pct: ${fallback_style.sizeAdjust.replace(/%/g, "")}`,
				`  ascent_override_pct: ${fallback_style.ascentOverride.replace(/%/g, "")}`,
	  		`  local_src: \"${fallback.local}\"`,
	  		"}",
	  	]
			div = document.createElement("div");
			div.classList.add("snippet");
			div.innerHTML = snippet.join("\n");
			container_el.appendChild(div);
  	}
  }
})();
</script>
</body>
</html>
